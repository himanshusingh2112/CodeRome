{
  "version": 3,
  "sources": ["../../lib0/mutex.js", "../../lib0/diff.js", "../../y-codemirror/src/y-codemirror.js"],
  "sourcesContent": ["/**\n * Mutual exclude for JavaScript.\n *\n * @module mutex\n */\n\n/**\n * @callback mutex\n * @param {function():void} cb Only executed when this mutex is not in the current stack\n * @param {function():void} [elseCb] Executed when this mutex is in the current stack\n */\n\n/**\n * Creates a mutual exclude function with the following property:\n *\n * ```js\n * const mutex = createMutex()\n * mutex(() => {\n *   // This function is immediately executed\n *   mutex(() => {\n *     // This function is not executed, as the mutex is already active.\n *   })\n * })\n * ```\n *\n * @return {mutex} A mutual exclude function\n * @public\n */\nexport const createMutex = () => {\n  let token = true\n  return (f, g) => {\n    if (token) {\n      token = false\n      try {\n        f()\n      } finally {\n        token = true\n      }\n    } else if (g !== undefined) {\n      g()\n    }\n  }\n}\n", "/**\n * Efficient diffs.\n *\n * @module diff\n */\n\nimport { equalityStrict } from './function.js'\n\n/**\n * A SimpleDiff describes a change on a String.\n *\n * ```js\n * console.log(a) // the old value\n * console.log(b) // the updated value\n * // Apply changes of diff (pseudocode)\n * a.remove(diff.index, diff.remove) // Remove `diff.remove` characters\n * a.insert(diff.index, diff.insert) // Insert `diff.insert`\n * a === b // values match\n * ```\n *\n * @template {string} T\n * @typedef {Object} SimpleDiff\n * @property {Number} index The index where changes were applied\n * @property {Number} remove The number of characters to delete starting\n *                                  at `index`.\n * @property {T} insert The new text to insert at `index` after applying\n */\n\nconst highSurrogateRegex = /[\\uD800-\\uDBFF]/\nconst lowSurrogateRegex = /[\\uDC00-\\uDFFF]/\n\n/**\n * Create a diff between two strings. This diff implementation is highly\n * efficient, but not very sophisticated.\n *\n * @function\n *\n * @param {string} a The old version of the string\n * @param {string} b The updated version of the string\n * @return {SimpleDiff<string>} The diff description.\n */\nexport const simpleDiffString = (a, b) => {\n  let left = 0 // number of same characters counting from left\n  let right = 0 // number of same characters counting from right\n  while (left < a.length && left < b.length && a[left] === b[left]) {\n    left++\n  }\n  // If the last same character is a high surrogate, we need to rollback to the previous character\n  if (left > 0 && highSurrogateRegex.test(a[left - 1])) left--\n  while (right + left < a.length && right + left < b.length && a[a.length - right - 1] === b[b.length - right - 1]) {\n    right++\n  }\n  // If the last same character is a low surrogate, we need to rollback to the previous character\n  if (right > 0 && lowSurrogateRegex.test(a[a.length - right])) right--\n  return {\n    index: left,\n    remove: a.length - left - right,\n    insert: b.slice(left, b.length - right)\n  }\n}\n\n/**\n * @todo Remove in favor of simpleDiffString\n * @deprecated\n */\nexport const simpleDiff = simpleDiffString\n\n/**\n * Create a diff between two arrays. This diff implementation is highly\n * efficient, but not very sophisticated.\n *\n * Note: This is basically the same function as above. Another function was created so that the runtime\n * can better optimize these function calls.\n *\n * @function\n * @template T\n *\n * @param {Array<T>} a The old version of the array\n * @param {Array<T>} b The updated version of the array\n * @param {function(T, T):boolean} [compare]\n * @return {SimpleDiff<Array<T>>} The diff description.\n */\nexport const simpleDiffArray = (a, b, compare = equalityStrict) => {\n  let left = 0 // number of same characters counting from left\n  let right = 0 // number of same characters counting from right\n  while (left < a.length && left < b.length && compare(a[left], b[left])) {\n    left++\n  }\n  while (right + left < a.length && right + left < b.length && compare(a[a.length - right - 1], b[b.length - right - 1])) {\n    right++\n  }\n  return {\n    index: left,\n    remove: a.length - left - right,\n    insert: b.slice(left, b.length - right)\n  }\n}\n\n/**\n * Diff text and try to diff at the current cursor position.\n *\n * @param {string} a\n * @param {string} b\n * @param {number} cursor This should refer to the current left cursor-range position\n */\nexport const simpleDiffStringWithCursor = (a, b, cursor) => {\n  let left = 0 // number of same characters counting from left\n  let right = 0 // number of same characters counting from right\n  // Iterate left to the right until we find a changed character\n  // First iteration considers the current cursor position\n  while (\n    left < a.length &&\n    left < b.length &&\n    a[left] === b[left] &&\n    left < cursor\n  ) {\n    left++\n  }\n  // If the last same character is a high surrogate, we need to rollback to the previous character\n  if (left > 0 && highSurrogateRegex.test(a[left - 1])) left--\n  // Iterate right to the left until we find a changed character\n  while (\n    right + left < a.length &&\n    right + left < b.length &&\n    a[a.length - right - 1] === b[b.length - right - 1]\n  ) {\n    right++\n  }\n  // If the last same character is a low surrogate, we need to rollback to the previous character\n  if (right > 0 && lowSurrogateRegex.test(a[a.length - right])) right--\n  // Try to iterate left further to the right without caring about the current cursor position\n  while (\n    right + left < a.length &&\n    right + left < b.length &&\n    a[left] === b[left]\n  ) {\n    left++\n  }\n  if (left > 0 && highSurrogateRegex.test(a[left - 1])) left--\n  return {\n    index: left,\n    remove: a.length - left - right,\n    insert: b.slice(left, b.length - right)\n  }\n}\n", "/**\n * @module bindings/textarea\n */\n\nimport { createMutex } from 'lib0/mutex'\nimport * as math from 'lib0/math'\nimport * as Y from 'yjs'\nimport * as func from 'lib0/function'\nimport * as eventloop from 'lib0/eventloop'\nimport { Observable } from 'lib0/observable'\nimport * as diff from 'lib0/diff'\nimport CodeMirror from 'codemirror'\n\nexport const cmOrigin = 'y-codemirror'\n\n/**\n * @param {CodemirrorBinding} binding\n * @param {any} event\n */\nconst typeObserver = (binding, event) => {\n  binding._mux(() => {\n    const cmDoc = binding.cmDoc\n    const cm = cmDoc.getEditor()\n    // Normally the position is right-associated\n    // But when remote changes happen, it looks like the remote user is hijacking your position.\n    // Just for remote insertions, we make the collapsed cursor left-associated.\n    // If selection is not collapsed, we only make \"to\" left associated\n    let anchor = cm.indexFromPos(cm.getCursor('anchor'))\n    let head = cm.indexFromPos(cm.getCursor('head'))\n    const switchSel = head < anchor\n    // normalize selection so that anchor < head, switch back later\n    if (switchSel) {\n      const tmp = head\n      head = anchor\n      anchor = tmp\n    }\n    const performChange = () => {\n      const delta = event.delta\n      let index = 0\n      for (let i = 0; i < event.delta.length; i++) {\n        const d = delta[i]\n        if (d.retain) {\n          index += d.retain\n        } else if (d.insert) {\n          if (index < anchor || (anchor < head && index === anchor)) {\n            anchor += d.insert.length\n          }\n          if (index < head) {\n            head += d.insert.length\n          }\n          const pos = cmDoc.posFromIndex(index)\n          cmDoc.replaceRange(d.insert, pos, pos, cmOrigin)\n          index += d.insert.length\n        } else if (d.delete) {\n          if (index < anchor) {\n            anchor = math.max(anchor - d.delete, index)\n          }\n          if (index < head) {\n            head = math.max(head - d.delete, index)\n          }\n          const start = cmDoc.posFromIndex(index)\n          const end = cmDoc.posFromIndex(index + d.delete)\n          cmDoc.replaceRange('', start, end, cmOrigin)\n        }\n      }\n    }\n    // if possible, bundle the changes using cm.operation\n    if (cm) {\n      cm.operation(performChange)\n    } else {\n      performChange()\n    }\n    if (switchSel) {\n      const tmp = head\n      head = anchor\n      anchor = tmp\n    }\n    cm.setSelection(cm.posFromIndex(anchor), cm.posFromIndex(head), { scroll: false })\n  })\n}\n\n/**\n * @param {CodemirrorBinding} binding\n * @param {Array<any>} changes\n */\nconst targetObserver = (binding, changes) => {\n  binding._mux(() => {\n    binding.doc.transact(() => {\n      const hasPaste = binding.yUndoManager && changes.some(change => change.origin === 'paste')\n      if (hasPaste) {\n        binding.yUndoManager.stopCapturing()\n      }\n\n      if (changes.length > 1) {\n        // If there are several consecutive changes, we can't reliably compute the positions anymore. See y-codemirror#11\n        // Instead, we will compute the diff and apply the changes\n        const d = diff.simpleDiffString(binding.type.toString(), binding.cmDoc.getValue())\n        binding.type.delete(d.index, d.remove)\n        binding.type.insert(d.index, d.insert)\n      } else {\n        const change = changes[0]\n        const start = binding.cmDoc.indexFromPos(change.from)\n        const delLen = change.removed.map(s => s.length).reduce(math.add) + change.removed.length - 1\n        if (delLen > 0) {\n          binding.type.delete(start, delLen)\n        }\n        if (change.text.length > 0) {\n          binding.type.insert(start, change.text.join('\\n'))\n        }\n      }\n\n      if (hasPaste) {\n        binding.yUndoManager.stopCapturing()\n      }\n    }, binding)\n  })\n  if (binding._pendingCursorEvent) {\n    binding._pendingCursorEvent = false\n    binding.emit('cursorActivity', [binding])\n  }\n}\n\nconst createRemoteCaret = (username, color) => {\n  const caret = document.createElement('span')\n  caret.classList.add('remote-caret')\n  caret.setAttribute('style', `border-color: ${color}`)\n  const userDiv = document.createElement('div')\n  userDiv.setAttribute('style', `background-color: ${color}`)\n  userDiv.insertBefore(document.createTextNode(username), null)\n  caret.insertBefore(userDiv, null)\n  setTimeout(() => {\n    caret.classList.add('hide-name')\n  }, 2000)\n  return caret\n}\n\nconst createEmptyLinePlaceholder = (color) => {\n  const placeholder = document.createElement('span')\n  placeholder.setAttribute('style', 'user-select: none;')\n  const emptyTxt = document.createElement('span')\n  emptyTxt.insertBefore(document.createTextNode(''), null)\n  const sel = document.createElement('span')\n  sel.setAttribute('class', 'y-line-selection')\n  sel.setAttribute('style', `display: inline-block; position: absolute; left: 4px; right: 4px; top: 0; bottom: 0; background-color: ${color}70`)\n  placeholder.insertBefore(sel, null)\n  placeholder.insertBefore(emptyTxt, null)\n  return placeholder\n}\n\nconst updateRemoteSelection = (y, cm, type, cursors, clientId, awareness) => {\n  // redraw caret and selection for clientId\n  const aw = awareness.getStates().get(clientId)\n  // destroy current text mark\n  const m = cursors.get(clientId)\n  if (m !== undefined) {\n    if (m.caret) {\n      m.caret.clear()\n    }\n    m.sel.forEach(sel => sel.clear())\n    cursors.delete(clientId)\n  }\n  if (aw === undefined) {\n    return\n  }\n  const user = aw.user || {}\n  if (user.color == null) {\n    user.color = '#ffa500'\n  }\n  if (user.name == null) {\n    user.name = `User: ${clientId}`\n  }\n  const cursor = aw.cursor\n  if (cursor == null || cursor.anchor == null || cursor.head == null) {\n    return\n  }\n  const anchor = Y.createAbsolutePositionFromRelativePosition(JSON.parse(cursor.anchor), y)\n  const head = Y.createAbsolutePositionFromRelativePosition(JSON.parse(cursor.head), y)\n  if (anchor !== null && head !== null && anchor.type === type && head.type === type) {\n    const headpos = cm.posFromIndex(head.index)\n    const anchorpos = cm.posFromIndex(anchor.index)\n    let from, to\n    if (head.index < anchor.index) {\n      from = headpos\n      to = anchorpos\n    } else {\n      from = anchorpos\n      to = headpos\n    }\n    const caretEl = createRemoteCaret(user.name, user.color)\n    // if position was \"relatively\" the same, do not show name again and hide instead\n    if (m && func.equalityFlat(aw.cursor.anchor, m.awCursor.anchor) && func.equalityFlat(aw.cursor.head, m.awCursor.head)) {\n      caretEl.classList.add('hide-name')\n    }\n    const sel = []\n\n    if (head.index !== anchor.index) {\n      if (from.line !== to.line && from.ch !== 0) {\n        // start of selection will only be a simple text-selection\n        sel.push(cm.markText(from, new CodeMirror.Pos(from.line + 1, 0), { css: `background-color: ${user.color}70;`, inclusiveRight: false, inclusiveLeft: false }))\n        from = new CodeMirror.Pos(from.line + 1, 0)\n      }\n      while (from.line !== to.line) {\n        // middle of selection is always a whole-line selection. We add a widget at the first position which will fill the background.\n        sel.push(cm.setBookmark(new CodeMirror.Pos(from.line, 0), { widget: createEmptyLinePlaceholder(user.color) }))\n        from = new CodeMirror.Pos(from.line + 1, 0)\n      }\n      sel.push(cm.markText(from, to, { css: `background-color: ${user.color}70;`, inclusiveRight: false, inclusiveLeft: false }))\n    }\n    // only render caret if not the complete last line was selected (in this case headpos.ch === 0)\n    const caret = sel.length > 0 && to === headpos && headpos.ch === 0 ? null : cm.setBookmark(headpos, { widget: caretEl, insertLeft: true })\n    cursors.set(clientId, { caret, sel, awCursor: cursor })\n  }\n}\n\nconst codemirrorCursorActivity = (y, cm, type, awareness) => {\n  const aw = awareness.getLocalState()\n  if (!cm.hasFocus() || aw == null || !cm.display.wrapper.ownerDocument.hasFocus()) {\n    return\n  }\n  const newAnchor = Y.createRelativePositionFromTypeIndex(type, cm.indexFromPos(cm.getCursor('anchor')))\n  const newHead = Y.createRelativePositionFromTypeIndex(type, cm.indexFromPos(cm.getCursor('head')))\n  let currentAnchor = null\n  let currentHead = null\n  if (aw.cursor != null) {\n    currentAnchor = Y.createRelativePositionFromJSON(JSON.parse(aw.cursor.anchor))\n    currentHead = Y.createRelativePositionFromJSON(JSON.parse(aw.cursor.head))\n  }\n  if (aw.cursor == null || !Y.compareRelativePositions(currentAnchor, newAnchor) || !Y.compareRelativePositions(currentHead, newHead)) {\n    awareness.setLocalStateField('cursor', {\n      anchor: JSON.stringify(newAnchor),\n      head: JSON.stringify(newHead)\n    })\n  }\n}\n\n/**\n * A binding that binds a YText to a CodeMirror editor.\n *\n * @example\n *   const ytext = ydocument.define('codemirror', Y.Text)\n *   const editor = new CodeMirror(document.querySelector('#container'), {\n *     mode: 'javascript',\n *     lineNumbers: true\n *   })\n *   const binding = new CodemirrorBinding(ytext, editor)\n *\n */\nexport class CodemirrorBinding extends Observable {\n  /**\n   * @param {Y.Text} textType\n   * @param {import('codemirror').Editor} codeMirror\n   * @param {any | null} [awareness]\n   * @param {{ yUndoManager?: Y.UndoManager }} [options]\n   */\n  constructor (textType, codeMirror, awareness = null, { yUndoManager = null } = {}) {\n    super()\n    const doc = textType.doc\n    const cmDoc = codeMirror.getDoc()\n    this.doc = doc\n    this.type = textType\n    this.cm = codeMirror\n    this.cmDoc = cmDoc\n    this.awareness = awareness || null\n    this.yUndoManager = yUndoManager\n    this._onStackItemAdded = ({ stackItem, changedParentTypes }) => {\n      // only store metadata if this type was affected\n      if (changedParentTypes.has(textType) && this._beforeChangeSelection) {\n        stackItem.meta.set(this, this._beforeChangeSelection)\n      }\n    }\n    this._onStackItemPopped = ({ stackItem }) => {\n      const sel = stackItem.meta.get(this)\n      if (sel) {\n        const anchor = Y.createAbsolutePositionFromRelativePosition(sel.anchor, doc).index\n        const head = Y.createAbsolutePositionFromRelativePosition(sel.head, doc).index\n        codeMirror.setSelection(codeMirror.posFromIndex(anchor), codeMirror.posFromIndex(head))\n        this._beforeChange()\n      }\n    }\n    if (yUndoManager) {\n      yUndoManager.trackedOrigins.add(this) // track changes performed by this editor binding\n      const editorUndo = cm => {\n        // Keymaps always start with an active operation.\n        // End the current operation so that the event is fired at the correct moment.\n        // @todo check cm.curOp in typeListener and endOperation always.\n        cm.endOperation()\n        yUndoManager.undo()\n        cm.startOperation()\n      }\n      const editorRedo = cm => {\n        cm.endOperation()\n        yUndoManager.redo()\n        cm.startOperation()\n      }\n      codeMirror.addKeyMap({\n        // pc\n        'Ctrl-Z': editorUndo,\n        'Shift-Ctrl-Z': editorRedo,\n        'Ctrl-Y': editorRedo,\n        // mac\n        'Cmd-Z': editorUndo,\n        'Shift-Cmd-Z': editorRedo,\n        'Cmd-Y': editorRedo\n      })\n\n      yUndoManager.on('stack-item-added', this._onStackItemAdded)\n      yUndoManager.on('stack-item-popped', this._onStackItemPopped)\n    }\n\n    this._mux = createMutex()\n    // set initial value\n    cmDoc.setValue(textType.toString())\n    // observe type and target\n    this._typeObserver = event => typeObserver(this, event)\n    this._targetObserver = (instance, changes) => {\n      if (instance.getDoc() === cmDoc) {\n        targetObserver(this, changes)\n      }\n    }\n    this._cursors = new Map()\n    this._changedCursors = new Set()\n    this._debounceCursorEvent = eventloop.createDebouncer(10)\n    this._awarenessListener = event => {\n      if (codeMirror.getDoc() !== cmDoc) {\n        return\n      }\n      const f = clientId => {\n        if (clientId !== doc.clientID) {\n          this._changedCursors.add(clientId)\n        }\n      }\n      event.added.forEach(f)\n      event.removed.forEach(f)\n      event.updated.forEach(f)\n      if (this._changedCursors.size > 0) {\n        this._debounceCursorEvent(() => {\n          this._changedCursors.forEach(clientId => {\n            updateRemoteSelection(doc, codeMirror, textType, this._cursors, clientId, awareness)\n          })\n          this._changedCursors.clear()\n        })\n      }\n    }\n    this._pendingCursorEvent = false\n    this._cursorListener = () => {\n      if (codeMirror.getDoc() === cmDoc) {\n        this._pendingCursorEvent = true\n        setTimeout(() => {\n          if (this._pendingCursorEvent) {\n            this._pendingCursorEvent = false\n            this.emit('cursorActivity', [codeMirror])\n          }\n        }, 0)\n      }\n    }\n    this.on('cursorActivity', () => {\n      codemirrorCursorActivity(doc, codeMirror, textType, awareness)\n    })\n    this._blurListeer = () => awareness.setLocalStateField('cursor', null)\n\n    textType.observe(this._typeObserver)\n    // @ts-ignore\n    codeMirror.on('changes', this._targetObserver)\n    /**\n     * @type {{ anchor: Y.RelativePosition, head: Y.RelativePosition } | null}\n     */\n    this._beforeChangeSelection = null\n    this._beforeChange = () => {\n      // update the the beforeChangeSelection that is stored befor each change to the editor (except when applying remote changes)\n      this._mux(() => {\n        // store the selection before the change is applied so we can restore it with the undo manager.\n        const anchor = Y.createRelativePositionFromTypeIndex(textType, codeMirror.indexFromPos(codeMirror.getCursor('anchor')))\n        const head = Y.createRelativePositionFromTypeIndex(textType, codeMirror.indexFromPos(codeMirror.getCursor('head')))\n        this._beforeChangeSelection = { anchor, head }\n      })\n    }\n    codeMirror.on('beforeChange', this._beforeChange)\n    if (awareness) {\n      codeMirror.on('swapDoc', this._blurListeer)\n      awareness.on('change', this._awarenessListener)\n      // @ts-ignore\n      codeMirror.on('cursorActivity', this._cursorListener)\n      codeMirror.on('blur', this._blurListeer)\n      codeMirror.on('focus', this._cursorListener)\n    }\n  }\n\n  destroy () {\n    this.type.unobserve(this._typeObserver)\n    this.cm.off('swapDoc', this._blurListeer)\n    // @ts-ignore\n    this.cm.off('changes', this._targetObserver)\n    this.cm.off('beforeChange', this._beforeChange)\n    // @ts-ignore\n    this.cm.off('cursorActivity', this._cursorListener)\n    this.cm.off('focus', this._cursorListener)\n    this.cm.off('blur', this._blurListeer)\n    if (this.awareness) {\n      this.awareness.off('change', this._awarenessListener)\n    }\n    if (this.yUndoManager) {\n      this.yUndoManager.off('stack-item-added', this._onStackItemAdded)\n      this.yUndoManager.off('stack-item-popped', this._onStackItemPopped)\n      this.yUndoManager.trackedOrigins.delete(this)\n    }\n    this.type = null\n    this.cm = null\n    this.cmDoc = null\n    super.destroy()\n  }\n}\n\nexport const CodeMirrorBinding = CodemirrorBinding\n"],
  "mappings": "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",
  "names": ["CodeMirror"]
}
